/*
 * Copyright (c) 2005-2006
 *    Brent Miller and Charles Morrey.  All rights reserved.
 *
 * See the COPYRIGHT_NOTICE file for terms.
 */

// $Id: qcomptree.h,v 1.10 2006/08/10 07:48:32 bmiller Exp $

#ifndef INCLUDE_comptree_h
#define INCLUDE_comptree_h 1


#include <vector>
#include <list>
#include "qtypes.h"
#include "qposinfo.h"
#include "parameters.h"



/* The idea behind a computation tree is to store whatever state helps
 * speed up the process of evaluating new positions.  This state is not
 * generally useful unless computing the score of new positions, so
 * we do not want to keep it stored indefinitely along with the scores
 * of positions.  It is kept for the life of a single call to iSearch,
 * then recycled from scratch for whatever position iSearch is next
 * called on.
 */

typedef guint32 qComputationTreeNodeId;
const qComputationTreeNodeId qComputationTreeNode_invalid = 0;
const qComputationTreeNodeId qComputationTreeNode_max = G_MAXUINT32;

typedef std::list<qComputationTreeNodeId> qComputationTreeNodeList;
typedef std::list<qComputationTreeNodeId>::iterator qComputationTreeNodeListIterator;
typedef std::list<qComputationTreeNodeId>::const_iterator qComputationTreeNodeListConstIterator;

/* PRIVATE LOCAL CLASS
 * qComputationNode class
 * Used privately by qComputationTree class.
 * !!! Relocate this declaration to inside the implementation file.
 */
  /* One idea was to have the evaluation routine's dijkstra algorithm
   * use our storage during computation of a position's score.  Then
   * if we have the graph generated by one invocation on a position; we
   * can use that graph to accelerate evaluation of adjacent positions.
   *
   * Unfortunately, I cannot figure out a practical way to make this work.
   * I wanted to define a set of frontier points adjacent to whatever
   * changed in the graph, and then ripple those points through, stopping
   * any frontier points that did not change their neighbors, but it was
   * too hard to detect which neighbors should and shouldn't be adjusted.
   *
   * It seems faster to just re-evaluate dijkstra than to try to correctly
   * locate and carry forward frontier points modifying an existing graph.
   *
   * An example of my thinking:
   * In the new position(s), call all squares adjacent to a wall move the
   * set of "affected nodes."
   * Find the affected node(s) with minimum score.  Without changing their
   * scores, move them to the "frontier set."
   * For all other affected nodes, NULL out their scores.
   * For all nodes in the frontier set:
   *   Remove the square from the frontier set.
   *   If an adjacent square has no existing score, give it current score+1,
   *     make it a frontier point, and remove it from the affected node set.
   *   If it has a higher score, give it current score+1 and make it a
   *     frontier point.
   *   What if it has a lower score???
   *
   * Anyway, using storage in these nodes would require a member like:
   * qDijkstraGraph dijkstraGraph;
   */
class qComputationNode {
public:
  // Info regarding the edge that leads to this node:
  qMove                      mv;    // what move led to the position in this node
  const qPositionEvaluation *eval;  // the score returned for that move

  // Note: by using eval pointers instead of copies, any time we free memory
  // from the positionHash we will be forced to discard the current state
  // of the computation tree and rebuild it.

  qComputationTreeNodeId              parentNodeIdx;
  std::list<qComputationTreeNodeId>   childNodes;

  // And now the saved state used to accelerate things...
  qPositionInfo           *posInfo;


  qComputationNode::qComputationNode()
  :parentNodeIdx(qComputationTreeNode_invalid),
   childNodes(0),
   posInfo(NULL)
    {
       this->mv = moveNull;
       this->eval = NULL;
    };
  qComputationNode::~qComputationNode() {;};
};

class qComputationTree {
 public:
  qComputationTree::qComputationTree();
  qComputationTree::~qComputationTree();

  // Sets all nodes to uninitialized
  void initializeTree();

  // Returns the root node
  qComputationTreeNodeId getRootNode() const;

  // addNodeChild: 
  // Adds an edge to the current node, leading to a new child node
  // Returns new child node's id, or qComputationTreeNode_invalid on failure.
  // Note: we store the mv's eval pointer instead of copying, so any time we
  // free memory from the positionHash we will be forced to discard the
  // current state of the computation tree and rebuild it.
  qComputationTreeNodeId addNodeChild(qComputationTreeNodeId node,
				      qMove mv,
				      const qPositionEvaluation *eval);

  // Returns if the specified node has any children recorded in the tree
  bool nodeHasChildList(qComputationTreeNodeId node) const;

  // Returns the list of children for a specified node.
  const qComputationTreeNodeList *getNodeChildList
    (qComputationTreeNodeId node) const;

/* OPTIMIZATION:
 * Sort the childList so client code doesn't have to scan the whole list
 * to find eligible moves.
 *
 * Scores of moves can change during evaluation of various branches of the
 * qComputationTree, so there is little guarantee that when we revisit a
 * node, its childList will still be sorted.  Our sorting algorithm should
 * be as fast as possible for nearly sorted lists, since only one or two
 * elements may have changed.
 *
 * Because we protect against evaluating circular loops in the qCompTree,
 * we do konw that if no other branches of the tree have been evaluated,
 * no nodes will have "changed out from underneath us."  Therefor, it
 * probably makes sense if each node remembers the branch most recently
 * traversed.  Whenever we walk down a different branch than last time,
 * we pass a flag along our way down indicating to re-sort each node along
 * the way.  Another thing we can do is, on the way back up the tree,
 * pass up the leaf that was last evaluated.  If the re-sort flag is not
 * set when we go back down, we can actually skip all intervening nodes
 * and jump straight to the leaf.  Jumping to the leaf node is complicated
 * though, because we'd need to somehow set the evaluation flag for all
 * intervening nodes.  What's more likely is we could skip resorting and
 * re-evaluating which node to follow until we reached the leaf node.
 *
 * All this would require changing the qComputationTree object to hold
 * a currentNodeId state, so that it becomes a "treewalking" object.
 * Calls such as "walkDown(node)" and "walkUp()" would need to be added.
 */

  // Because we usually want to find the move yielding the worst possible
  // eval for our opponent, this reverse sorts a node's child list by
  // eval.score + eval.complexity
  // After calling this, use getNodeChildList to access the sorted list
  // Returns the node with the lowest score
  qComputationTreeNodeId sortNodeChildList
    (qComputationTreeNodeId node);

  // Returns the childNode with the lowest eval.score
  qComputationTreeNodeId getBestScoringChild(qComputationTreeNodeId node) const;

  qComputationTreeNodeId getNodeParent(qComputationTreeNodeId node) const;

  qPositionInfo *getNodePosInfo(qComputationTreeNodeId node) const;
  void setNodePosInfo(qComputationTreeNodeId node, qPositionInfo *posInfo);

  void setNodeEval(qComputationTreeNodeId     node,
		   const qPositionEvaluation *eval);
  const qPositionEvaluation *getNodeEval(qComputationTreeNodeId node) const;

  qMove getNodePrecedingMove(qComputationTreeNodeId node) const;

#ifdef DEBUG
  // examine the child list
  qComputationTreeNodeId getNodeNthChild(qComputationTreeNodeId node,
                                         int n);
#endif

 private:

  // Maybe replace these with simple arrays, if we're sure we won't need to
  // grow them (or if we can get by without the graph)
  std::vector<qComputationNode> nodeHeap;

  qComputationTreeNodeId nodeNum; // lowest free node
  qComputationTreeNodeId maxNode; // highest existing node; alloc more when used

  inline bool growNodeHeap()
    { 
      if (nodeHeap.size() > qComputationTreeNode_max - COMPTREE_GROW_SIZE)
        return FALSE;
      nodeHeap.resize(COMPTREE_GROW_SIZE + nodeHeap.size());
      maxNode = nodeHeap.size() - 1;
      return TRUE;
    };
  void qComputationTree::resetBestChild(qComputationNode &n);
};

extern const qComputationNode emptyNode;
#endif // INCLUDE_comptree_h
