??? Verify what X & O are used for (white & black) on quoridor mail server

??? flow/state diagram

=== Item 1.  References

Here is decent write-up describing the protocol used for most
Internet Chess Servers (ICS).
http://www.tim-mann.org/xboard/engine-intf.html

Reading it reveals some good (and bad) ideas for what to use in our
protocol.

=== Item 2.  Format of each command

Brent:  pick myself???  ---look for XML encoding implementations?
Check IVM's website--they have a parsing engine for java.  Xerces?

To speed the of development of our parsing code, I think we should
arrange every command to be a key/value pair (KVP) or argument vector (AV).
This allows us to pick any existing protocol for string-encoding KVPs or AVs.

Since we're writing over sockets, there has to be some delimiter so that
we know when we've received an entire encoded command.  Probably terminate
each encoding with a '\n' or '\0'...but anything that works is fine.

Some examples of prospective implementations from java are the
com.apple.dnssd.TXTRecord class for converting key/value object pairs
into text strings, or java.util.Vector, which has a toString function.
But I'm not sure if there are any C/C++/perl/python implementations for
either of those.

Do you happen to know of any suitable KVP or AV string encoding
implementations?  If not, I'll continue to investigate and something.

=== Item 3.  The commands

Per Item 2, each command will consist of KVP or AV text strings.  The keys
will be commands, and the value(s) will be whatever parameters are required
for each particular command.

I decided to make the commands symmetrical--two viewers could connect to each
other and play a game against each other just as well as a viewer against
a computer opponent.  This may turn out to be a bad decision, but if it
does I think we can extend the "language" of the protocol with some
server-side specific commands and viewer-specific commands.

In the mean time, any command you might send is also a command you might
receive.

I propose the following list of commands for the initial draft:

hello
  arg1: name of client
Connecting viewer sends this immediately upon establishing a connection.
No response is necessary upon receiving this.

protover
  arg1: "0.1" protocol version number (a decimal string)
Connecting viewer sends this immediately after "hello" command.
This describes the protocol version the viewer will proceed using.
If the client receives a protover command specifying a different
version number, the viewer can:
(1) if the received protover number matches the viewer's last-sent
version number, the viewer can proceed;
(2) if the received protover number is higher than the viewer's last-
sent version number, the viewer should simply wait for the remote
side to quit or resend another protover with a lower number.
(3) if the received protover number is less than the viewer's last-
sent version number, the viewer can send another protover command with
a version number equal to or lower than the received version number,
or send a "quit" command.

feature (optional)
  arg1: feature name
  args2+: arguments specific to the requested feature
This request asks if whoever is at the connection's other endpoint supports
some feature.  They can respond with "accepted" or "rejected" commands to let
your viewer know whether it is ok to continue making use of the feature in
question.  No examples as of this writing, but this can be used to extend
future versions without changing the communication protocol.
   The initial viewer should probably not have any code for sending feature
commands, and just respond to any it receives with "rejected"

accepted
rejected
  arg1: Name of feature queried by server
This is sent in response to the "feature" command from the server described
below.

new (optional)
  arg1: "confirmed" (optional)
Request to reset game to initial state and configuration.  If we receive
a "new" command from the opponent before we have sent any "move" commands,
then we must immediately send a "new confirmed" (arg1="confirmed")
command to the opponent, indicating that our viewer has been reset.

??? fix grammar:
If we receive a "new confirmed" command, and we have sent a "new" command
without both a subsequent "move" sent and thereafter a subsequent "move"
received, then we must enter a new state.  

If we receive a "new confirmed"
without having first sent a "new" command or after having made and received
a move, then we can either respond with an error or honor the "new confirmed"
command with our own "new confirmed" response.

Maybe add a "withdraw new request" command??? [no, not at first]

??? define when color negotion happens (after new???)
Make this part of the new command?
white
  No args
Request UI client to control white pawn (O) & server computer to play black
If opponent sends a "black" request, proceed with moving.

black
  No args
Request UI client to control black pawn (X) & server computer to play white
If opponent sends a "white" request, proceed waiting for opponent to move.

move
  arg1: "O" (white) or "X" (black) (not sure about this arg)
  arg2: some notation designating the move
  arg3: decimal whole number of walls remaining (not sure about this arg)
This requests the server to make the specified move, either a pawn move or
a wall drop.  

For notation, I suggest the following:
??? Alternate scheme:
Labels squares by row & column (A-I & A-9), &:
Use coordinates for pawn moves (i.e. xD6 or oF7);
Use .5s for wall moves, using infix for orientation:  C.5-3.5  or D.5|1.5


(R = A-H, C=1-8)
"|RC" - place a "vertical" wall centered at row R, column C
"-RC" - place a "horizontal" wall centered at row R, column C.
or a integer between 1 and 81 naming the square to which to move the pawn.
1 is the lower left-hand square (near A1), 9 is the lower right (near H1),
72 is the upper left (near A8), and 81 is upper right (near H8).  The
O pawn always starts at 5 and the X pawn always starts at 77.  I'm not
real happy using numbers for the squares, but I wanted to specify an
absolute location where the pawn ends up (instead of relative), and the
alternative was to re-use A-I and 1-9 coordinates, so they'd be used for
both wall placements and pawn moves.


            A   B   C   D   E   F   G   H            
            |   |   |   |   |   |   |   |
        +-----------------------------------+
        | 72              X               81|          
     8--|   +   +   +   +   +   +   +   +   |--8  
        |       |                           |     
     7--|   +   |   +   +-------+-------+   |--7  
        |       |       |                   |     
     6--|-------+-------|-------+-------+   |--6        
        |               |                   |          
     5--|   +   +   +   +   +   +   +   +   |--5        
        |               |                   |     
     4--|   +   +   +   |   +   +   +-------|--4        
        |               |                   |          
     3--|   +   +   +   +-------+   +   +   |--3
        |                                   |    
     2--|   +   +   +   +   +   +   +   +   |--2
        |                       |           |    
     1--|   +   +   +   +   +   |   +   +   |--1        
        | 1               O     |         9 |          
        +-----------------------------------+
            |   |   |   |   |   |   |   |
            A   B   C   D   E   F   G   H            

I examined the notation used by Richard's Quoridor Server
(http://www.gamerz.net/~pbmserv/quoridor.html), but decided that the
notation it used was not robust enough.  For example, pawn moves are always
relative, so it would be hard to detect an inconcistent state if both
ends of the connection did not agree on a pawn location.  And there's
no verification of whose piece or wall is moving.  So I modified the
notation slightly.

ackmove
  args: same as "move"
Responds to opponent acknowledging receipt and acceptability of a move.
???

mverror
  arg1: error message (optional)
  arg2: the move that was received (arg1 from client "move" command)
Sent if a move was received that the viewer does not accept (i.e. the
move is not legal, or it is not the opponent's turn, etc.)
??? Now what??? (back up the bad move & return to the "moving" state)

?
  No Args
Request the opponent to move immediately (abort thinking)
Opponent is not required to honor request.

cmderror
  arg1: error message (optional)
  args2+: command & arguments received that were bad
The specified command was received from the opponent and is not proper.
The bad command is discarded without being honored.

error
  args1+: textual message
??? Now what???

getboard
setboard
  arg1: 
??? Ability to set up a starting state

gamestate
  arg1: string encapsulation of board's state
Tell other side what the current game state is
How do we encapsulate the state???
Xpawn_location,Ypawn_location,whose_move,Xwalls,Ywalls,wall_locations...

quit
  No args
End game immediately.  This could be the same as dropping a connection, unless
we want to allow resuming a game after losing a connection.

[optional]
savegame:
  arg1: gamename(string) [optional]
restoregame:
  arg1: gamename (string) [optional]
This should be a "feature."

COMMANDS WE DON'T NEED YET:

tell (optional)
  arg1: "you" "others" "all" ???
  arg2: textual string
Request to display included text message for the opposing player

resign
  arg1: X or O
Specified player loses.  ("X" or "O" arg is included for sake of being
able to use viewer to spectate a game between two other parties.)

{pause}
{resume}
  Request opponent to stop thinking & consuming CPU, (and stop any move
  timers in effect); or resume thinking.
  Once paused, the only valid next commands are resume, quit.
{ping}
  arg1: integer (N)
  Requests opponent to send back "pong N" upon completing all previous
  commands.
{setboard}
  arg1: some notation for representing a position.
{undo}
  Undo last move (two plies)
{variant}
  arg1: name of variant of normal game
  arg2+: ars for variation
Request to play variation of normal rules.
{force}
  Request no opponent; client will make all moves
{go}
  Request opponent to resume making moves, starting with current move.
{playother}
  Request opponent to resume playing as color who is not currently to move
{random}
 arg1: decimal whole number, 0-100?
  Requests opponent to play with some degree of randomness in his/her moves.


=== Item 4. Connection specification

How about if an argument (or config item) to the viewer is a machine name
(IP addr or hostname) and port number?  It would be nice if the viewer
also had listen functionality so you could make it listen for a connection
at a specified port number, but for starters we can get by with just
always trying to connect.  If we want to play two viewers against
each other, it'd be easy enough to use a tiny "relayer" to sit between two
viewers forwarding each other's traffic to each other.

For starters, don't have viewer listen.  Just give viewer ip addr & port no.
